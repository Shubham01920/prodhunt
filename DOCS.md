# prodhunt — Project Documentation

## Overview

`prodhunt` is a Flutter-based Product Hunt–style app that showcases products, supports upvotes, trends, admin moderation, and Firebase backend services.

Key technologies:

- Flutter (multi-platform: Android, iOS, Web, Windows, macOS, Linux)
- Firebase (Firestore, Storage, Auth, Cloud Functions)
- TypeScript Cloud Functions (in `functions/`)
- Charts via `fl_chart`

This document summarizes the repository structure, how to run the project locally, build & deploy, and where to find important app pieces.

---

**Repository layout (important files & folders)**

- `android/`, `ios/`, `web/`, `windows/`, `macos/`, `linux/` — platform folders generated by Flutter.
- `lib/` — main Flutter app code.
  - `lib/main.dart` — app entrypoint.
  - `lib/firebase_options.dart` — generated Firebase configuration used by `Firebase.initializeApp()`.
  - `lib/pages/` — application pages (e.g. `admin_panel.dart`, `homepage.dart`).
    - `lib/pages/admin_panel.dart` — Admin dashboard UI: quick stats (pending/approved/rejected), top trending bar chart (by upvotes), monthly uploads line chart, and expandable lists that query Firestore by status.
  - `lib/model/` — data models used across the app.
    - `lib/model/category_model.dart` — `CategoryModel` with serialization helpers (`toMap`, `fromMap`, `fromFirestore`) and utility methods (e.g. `getDefaultCategories()`, `getActiveCategories()`).
  - `lib/services/` — services interacting with Firebase (e.g. `firebase_service.dart`, `product_service.dart`, etc.).
  - `lib/widgets/`, `lib/ui/`, `lib/utils/` — UI components, theming and helpers.
- `functions/` — Cloud Functions (TypeScript) for server-side logic. Contains `src/index.ts`, `package.json`, and TypeScript configs.
- `assets/` — static assets used by the app (images, etc.).
- `pubspec.yaml` — Flutter dependencies and assets configuration.
- `firebase.json` & `firebaserc` (if present) — Firebase project configuration and deploy targets.

---

## Quick setup (developer machine)

Prerequisites:

- Flutter SDK (stable channel recommended). See https://docs.flutter.dev/get-started/install
- Node.js & npm (for Cloud Functions)
- Firebase CLI (for local emulators and deploy): `npm install -g firebase-tools`
- (Optional) Android Studio / Xcode for platform tooling

Windows PowerShell commands to prepare the project:

```powershell
# 1) Install Dart/Flutter & ensure `flutter` is on PATH
flutter --version

# 2) Get Dart/Flutter packages
cd D:\Purplemerit\prodhunt; flutter pub get

# 3) Install Cloud Functions dependencies
cd functions; npm install
```

Note: If your project uses a generated `firebase_options.dart` it should already be present under `lib/`. Android (`google-services.json`) and iOS (`GoogleService-Info.plist`) config files are present in `android/app/` and `ios/Runner/` respectively in this repo.

---

## Running the app locally

From the repository root (PowerShell):

```powershell
# Run on default connected device (or emulator)
cd D:\Purplemerit\prodhunt; flutter run

# Run tests
flutter test

# Format code
flutter format .
```

If you want to run the Firebase Emulator Suite for local development (recommended when testing functions or Firestore rules):

```powershell
# Start emulator from repo root (configure in firebase.json)
firebase emulators:start
```

---

## Build & Release

Android (APK):

```powershell
cd D:\Purplemerit\prodhunt; flutter build apk --release
```

iOS (release):

- Open Xcode workspace at `ios/Runner.xcworkspace` and follow Apple signing & archive process.

Web:

```powershell
cd D:\Purplemerit\prodhunt; flutter build web
```

---

## Cloud Functions (deploy)

Deploy functions with Firebase CLI from `functions/`:

```powershell
cd D:\Purplemerit\prodhunt\functions; npm run build # if TypeScript build step exists
firebase deploy --only functions
```

You can also deploy hosting, firestore rules, etc. via `firebase deploy` with appropriate flags.

---

## Important Implementation Notes

- Firestore collections used across the app are centralized in `lib/services/firebase_service.dart` (see that file to find collection names like `productsRef`). This keeps queries consistent across the UI and functions.

- The admin page (`lib/pages/admin_panel.dart`) uses realtime `StreamBuilder`s to:

  - Count documents by `status` to show Pending/Approved/Rejected stats.
  - Query top 7 products ordered by `upvoteCount` for the trending bar chart.
  - Aggregate `createdAt` timestamps to show monthly uploads for a selected year.
  - Display expandable lists for each product status using queries like `where('status', isEqualTo: status).orderBy(orderBy, descending: true)`.

- `lib/model/category_model.dart` contains `CategoryModel` with helper constructors `fromFirestore` and `fromMap` that are resilient to `Timestamp` or string date fields. Utility methods include `getDefaultCategories()` and `getActiveCategories()` (returns categories where `isActive == true`).

---

## Testing and Static Analysis

Run tests:

```powershell
cd D:\Purplemerit\prodhunt; flutter test
```

Run static analysis / linter (if configured):

```powershell
flutter analyze
```

Format all Dart files:

```powershell
flutter format .
```

---

## Contributing

- Follow the existing code style.
- Add unit/widget tests for new pages or logic.
- Open PRs against the `main` branch and include a short description of changes.

---

## Where to look next (key files)

- `lib/main.dart` — app entry point & Firebase initialization
- `lib/services/firebase_service.dart` — Firestore collection refs
- `lib/pages/admin_panel.dart` — admin dashboard UI & charts
- `lib/model/category_model.dart` — category data model and helpers
- `functions/src/index.ts` — cloud function entry points

---

---

## Detailed Explanation of Project Code

### 1. Architecture Overview

The app follows a modular architecture typical for Flutter projects, with clear separation between models, services, UI pages, and widgets. Firebase is used for backend data (Firestore, Auth, Storage), and Cloud Functions (TypeScript) provide server-side logic.

**Layers:**

- **Model Layer:** Defines data structures (e.g., `CategoryModel`, `ProductModel`) and serialization logic for Firestore and Dart.
- **Service Layer:** Handles business logic and communication with Firebase (e.g., `firebase_service.dart`, `product_service.dart`).
- **UI Layer:** Contains pages (`lib/pages/`), widgets (`lib/widgets/`), and helpers for building the app interface.
- **Cloud Functions:** Server-side logic in `functions/` for triggers, validation, and advanced queries.

### 2. Main Flows

#### App Startup

- Entry point: `lib/main.dart` initializes Firebase using `firebase_options.dart`.
- Loads the initial page (e.g., homepage, login, or admin panel depending on user role).

#### Data Fetching & Display

- Services (e.g., `firebase_service.dart`) expose Firestore collection references and query helpers.
- Pages use `StreamBuilder` or `FutureBuilder` to listen to Firestore changes and update UI in real time.
- Example: `admin_panel.dart` uses `StreamBuilder` to show live stats and trending products.

#### Product Moderation (Admin)

- Admin dashboard (`admin_panel.dart`) displays:
  - Quick stats (pending/approved/rejected) by counting Firestore documents.
  - Trending products (bar chart) by querying top 7 by `upvoteCount`.
  - Monthly uploads (line chart) by aggregating `createdAt` timestamps.
  - Expandable lists for each status, using queries like `where('status', isEqualTo: status)`.

#### Category Management

- `CategoryModel` (in `model/category_model.dart`) provides:
  - Serialization (`toMap`, `fromMap`, `fromFirestore`) for Firestore compatibility.
  - Utility methods: `getDefaultCategories()` (returns built-in categories), `getActiveCategories()` (filters by `isActive`).
  - Example usage: When displaying categories, use `CategoryModel.getActiveCategories(categories)` to show only active ones.

#### Cloud Functions

- Located in `functions/src/index.ts`.
- Used for backend logic like sending notifications, validating product submissions, or aggregating data.
- Functions are triggered by Firestore events or HTTP requests.

### 3. File Interactions & Examples

- **`lib/main.dart`**

  - Imports `firebase_options.dart` and initializes Firebase.
  - Sets up the root widget and navigation.

- **`lib/services/firebase_service.dart`**

  - Centralizes Firestore collection references (e.g., `productsRef`, `categoriesRef`).
  - Used by all pages/services for consistent queries.

- **`lib/pages/admin_panel.dart`**

  - Imports `firebase_service.dart` for data access.
  - Uses `StreamBuilder` to listen to product changes and update charts/lists.
  - UI logic is split into helper widgets (e.g., `_dashboardStats`, `_trendingProductsGraph`).

- **`lib/model/category_model.dart`**

  - Defines the `CategoryModel` class with fields for id, name, description, icon, color, product count, etc.
  - Includes factory constructors for Firestore and Map serialization.
  - Utility methods for filtering and default data.

- **`functions/src/index.ts`**
  - Entry point for Cloud Functions.
  - Exports functions for triggers (e.g., on product creation, send notification).

### 4. Example: Adding a New Feature

Suppose you want to add a "Featured" category for products:

1. Update `CategoryModel` to include a `isFeatured` field.
2. Update Firestore rules and Cloud Functions to handle featured logic.
3. Add UI elements in relevant pages (e.g., homepage, admin panel) to display featured products.
4. Use services to query products where `isFeatured == true`.

### 5. Data Flow Example

1. User submits a new product via a form (UI page).
2. The form calls a service (e.g., `product_submit_service.dart`) to validate and upload data to Firestore.
3. Firestore triggers a Cloud Function (if configured) to send notifications or update aggregates.
4. The admin panel listens for new products and updates the pending list in real time.

### 6. Testing & Maintenance

- Unit and widget tests are placed in `test/`.
- Static analysis via `flutter analyze` helps catch errors early.
- Code formatting via `flutter format .` ensures consistency.

---

This detailed explanation should help you understand how the codebase is structured, how data flows through the app, and how to extend or maintain the project. For specific code walkthroughs, see the comments in each file or request a deep dive into any module.
